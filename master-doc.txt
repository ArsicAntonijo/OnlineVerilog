\documentclass[master, hints]{finthesis}

\usepackage{subcaption}
\usepackage{tikz}
\usetikzlibrary{through, patterns}

\addbibresource{main.bib}

\title{Пројектовање интернет апликације за учење и вежбање верилог језика}
\author{Антонијо Арсић}
\studid{433/2021}
\advisor{Др Милан Чабаркапа}
\advisorfull{Др Милан Чабаркапа,\\доцент}

\studprog{Електротехника и рачунарство}
% \module{Модул}
\course{Одабрана поглавља из пројектовања пословних апликација}
% \date{\today}
\date{2024-09-02}

\committee{Др Владимир Миловановић}
\committee{...}

\studentshould{% У оквиру овог рада кандидат треба да...
    приликом пријаве \thesiscase{ог} рада ментор задаје тему по правилу преузету са листе тема коју је усвојила одговарајућа Катедра Факултета. Циљ \thesiscase{ог} рада је да студент  докаже способност примене стечених знања и вештина при решавању задатака који су у складу са усвојеним исходима знања. Препорука је да \thesiscase{и} рад буде пројекат мањег обима, експериментално-лабораторијско испитивање, примена инструменталне методе, прегледни рад, теоријска разрада, компјутерска симулација једноставнијег реалног проблема и сл. Након одобравања теме, ментор је дужан да студента упути у начин обраде теме, упути га на додатну литературу, одреди обим \thesiscase{ог} рада и током консултација усмерава и контролише рад кандидата. 
}

\titlepagebib{greenwade93}
\titlepagebib{pythonsite}

\thesisapplicationfile{slike/prijava}

\abstracten{
    This is the abstract. I like writing. This is the abstract. I like writing. This is the abstract. I like writing. This is the abstract. I like writing. This is the abstract. I like writing. This is the abstract. I like writing. This is the abstract. I like writing. This is the abstract. I like writing. This is the abstract. I like writing. This is the abstract. I like writing.
}
\keywordsen{abstract, writing}

\abstractsr{
    Ово је апстракт. Волим да пишем. Ово је апстракт. Волим да пишем. Ово је апстракт. Волим да пишем. Ово је апстракт. Волим да пишем. Ово је апстракт. Волим да пишем. Ово је апстракт. Волим да пишем. Ово је апстракт. Волим да пишем. Ово је апстракт. Волим да пишем. Ово је апстракт. Волим да пишем. Ово је апстракт. Волим да пишем.
}
\keywordssr{апстракт, писање}

% Semantic markup. Look it up!
\newcommand{\cmd}[2][]{\texttt{\textbackslash #2#1\{\ldots\}}} % Well, this one is useful beyond just semantics...
\newcommand{\env}[1]{\texttt{#1}}
\newcommand{\pkg}[1]{\texttt{#1}}
\newcommand{\prog}[1]{\texttt{#1}}

\begin{document}

\maketitle

\tableofcontents

\makeabstract

\section{Увод}

Ово је увод. Не волим да пишем.

\subsection{Слика говори више од хиљаду речи}

Изрека ,,слика говори више од хиљаду речи'' попримила је додатно значење у контексту писања радова. Наиме, поред тога што са собом носи доста информација које би иначе имале опширну текстуалну репрезентацију, слика такође заузима значајан простор на папиру у којем би могло стати доста речи. Тако да, са циљем скраћивања напора приликом писања текста, тенденција је да се у рад убаци и доста слика---често су и већих димензија него што је заиста потребно---да би се остварио одрећени број страна у раду. Додатна предност овом приступу је што се такође подиже естетски ниво рада. На слици~\ref{fig:slika} може се видети пример слике.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{slike/frog}
    \caption{Пример слике. Обавезно користити наредбу \cmd{label} \emph{после} наредбе \cmd{caption}! Генерално, најлакше је само користити наредбу \cmd{label} као последњу наредбу унутар било ког окружења да би означавање радило како треба.}
    \label{fig:slika}
\end{figure}

Једна можда мање позната предност дарежљивости са сликама у радовима ради скраћивања количине текста је та да, поред тога што олакшава посао аутору, такође олакшава посао и рецензенту. Упркос укорима који се ауторима упућују када се оваква пракса злоупотребљава, рецензентима је заправо потајно драго \cite{greenwade93}.

\subsection{Векторска графика}

\LaTeX\ има уграђену подршку за креирање векторских слика. Предност векторских слика у односу на растерске је та што сама слика није сачињена од пиксела, него већ од облика који имају неку математичку репрезентацију. Приликом приказа, из векторске слике се изводе пиксели, али ти пиксели никада не буду већи од самих пиксела на екрану \cite{quint2003scalable}. Захваљујући векторсој графици могуће је направити слике које могу бесконачно да се увећавају без губитка квалитета.

У \LaTeX-у постоји пакет \pkg{tikz} преко којег може да се прави векторска графика у самом документу. На слици~\ref{fig:worstcase} приказан је пример векторске графике. Овде је такође илустрован један од начина на који могу да се слике ставе једна до друге; у овом случају такође важи семантика да се једна ,,слика'' састоји из више ,,под-слика,'' а то су слике~\ref{fig:worstcase:faraway}~и~\ref{fig:worstcase:center}. За реализацију под-слика користи се окружење \env{subfigure} које се ставља унутар окружења \env{figure}. Окружење \env{subfigure} омогућује пакет \pkg{subcaption}. Даље ће бити мало више речи о паковању слика.

\begin{figure}[ht]
    \begin{subfigure}[t]{0.48\linewidth}
        \centering
        \begin{tikzpicture}[x=0.078\linewidth, y=0.078\linewidth]
            \coordinate [label=above:$U$] (U) at (-9,10);
            \coordinate [label=left:$M$] (M) at (0,3);
            
            \draw[dashed] (1,  0) -- (1, 10);
            
            \draw[dashed] (-9, 1) -- (3,  1);
            
            \draw[dashed] (0,  0) -- (0, 10);
            \draw[dashed] (2,  0) -- (2, 10);

            \draw[dashed] (-9, 0) -- (3,  0);
            \draw[dashed] (-9, 2) -- (3,  2);

            % \fill[pattern=north east lines] (0,0) rectangle (3,2);
            
            \draw ([shift={(0:11.4018)}]U) arc(0:-62:11.4018);
            \draw (U) -- (M);
            
            \foreach \x in {0,...,3}
                \foreach \y in {0,...,3}
                    {\fill (\x,\y) circle[radius=2pt];}
            \fill (U) circle[radius=2pt];
        \end{tikzpicture}
        \caption{Тачка~$M$ је најближа улазној тачки~$U$, али то растојање је веће од растојања тачке~$U$ од свих хиперравни које деле простор.}
        \label{fig:worstcase:faraway}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.48\linewidth}
        \centering
        \begin{tikzpicture}[x=0.0355\linewidth, y=0.0355\linewidth]
            \draw[dashed] (0, -11) -- (0, 11);

            \draw[dashed] (-11, -3.83) -- (0, -3.83);
            \draw[dashed] (0, 0) -- (11, 0);

            \draw[dashed] (-7.07, -11) -- (-7.07, -3.83);
            \draw[dashed] (-9.24, -3.83) -- (-9.24, 11);
            \draw[dashed] (7.07, -11) -- (7.07, 0);
            \draw[dashed] (3.82, 0) -- (3.82, 11);

            \draw[dashed] (-11, -7.07) -- (-7.07, -7.07);
            \draw[dashed] (-7.07, -10) -- (0, -10);
            \draw[dashed] (-11, 0) -- (-9.24, 0);
            \draw[dashed] (-9.24, 7.07) -- (0, 7.07);
            \draw[dashed] (0, -9.24) -- (7.07, -9.24);
            \draw[dashed] (7.07, -3.83) -- (11, -3.83);
            \draw[dashed] (0, 9.24) -- (3.83, 9.24);
            \draw[dashed] (3.83, 3.83) -- (11, 3.83);

            \foreach \i in {0,...,15} {
                \coordinate (A\i) at (\i*360/16:10);
                \fill (A\i) circle (2pt);
            }
            
            \coordinate [label=left:$U$] (U) at (0, 0);
            \coordinate [label=right:$M$] (M) at (A10);
            \fill (U) circle[radius=2pt];

            \draw (U) -- (M);
            \node [draw] at (U) [circle through={(M)}] {};

            % \fill[pattern=north east lines] (-11, -11) rectangle (-7.07, -7.07);
            \fill[pattern=north east lines] (-7.07, -11) rectangle (0, -10);
        \end{tikzpicture}
        \caption{Тачке у стаблу су распоређене у кругу са центром у улазној тачки~$U$. Осенчени правоугаоник представља једини потпростор који се неће посећивати.}
        \label{fig:worstcase:center}
    \end{subfigure}

    \caption{Илустрација најгорих случајева за рад NNS алгоритма у дводимензионалном ($k = 2$) простору.}
    \label{fig:worstcase}
\end{figure}

\subsection{Паковање суседних слика}

Слике које су постављене једна до друге не морају нужно бити део једне целине. За независне слике које су постављене хоризонтално једна до друге може се користити \env{minipage} окружење унутар \env{figure} окружења, што се може видети на сликама~\ref{fig:logos:unikg}~и~\ref{fig:logos:finkg}.

\begin{figure}[ht]
    \centering
    \caption{Велика слика.}
    \label{fig:logos:before}
    \begin{minipage}{0.3\linewidth}
        \centering
        \includegraphics[width=\linewidth]{finthesis_assets/unikg_logo}
        \caption{Лого Универзитета у Крагујевцу.}
        \label{fig:logos:unikg}
    \end{minipage}
    \hspace{5em}
    \begin{minipage}{0.3\linewidth}
        \centering
        \includegraphics[width=\linewidth]{finthesis_assets/finkg_logo}
        \caption{Лого Факултета инжењерских наука Универзитета у Крагујевцу.}
        \label{fig:logos:finkg}
    \end{minipage}
    \caption{Опет као велика слика.}
    \label{fig:logos:after}
\end{figure}

Међутим, ако се искористи наредба \cmd{caption} и унутар \env{figure} окружења, опет се целина која се налази унутар \env{figure} окружења може означити као посебна слика. Ако се наредба \cmd{caption} стави на првом месту унутар \env{figure} окружења, означавање слике се врши изинад саме слике. На ,,сликама''~\ref{fig:logos:before}~и~\ref{fig:logos:after} означене су саме слике~\ref{fig:logos:unikg}~и~\ref{fig:logos:finkg}, али и њихова целина је такође означена, на местима изнад и испод слика. Позиционирањем наредбе \cmd{caption} бира се шта ће тачно и где ће бити означено унутар неког окружења.

Уколико је потребно паковати више слика без појединачног означавања сваке слике, него само са означавањем целине као једну слику, онда није неопходно \env{minipage} окружење. Наредба \cmd[{[\ldots]}]{includegraphics} увози слику која се третира као било који други елемент документа. У том смислу слике су сличне као било који други карактер, само што су им димензије углавном веће. Свакако, слике саме по себи је могуће паковати произвољно. Слика~\ref{fig:pyramid} састоји се из шест слика које су спаковане као пирамида.

\begin{figure}[ht]
    \newcommand{\pic}[1]{\includegraphics[width=0.3\linewidth, height=0.1\textheight, keepaspectratio]{#1}}
    \centering
    
    \pic{slike/frog}
    
    \pic{finthesis_assets/unikg_logo}
    \pic{finthesis_assets/finkg_logo}
    
    \pic{finthesis_assets/finkg_logo}
    \pic{slike/prijava}
    \pic{finthesis_assets/unikg_logo}
    
    \caption{Пирамида сачињена из различитих слика.}
    \label{fig:pyramid}
\end{figure}

Ради илустрације да се слике у \LaTeX-у, ван \env{figure} окружења, третирају исто као било који други карактер приликом паковања, оставља се следећа порука коју би требало дешифровати:

{
\newcommand{\pic}[2][1ex]{\includegraphics[width=#1]{#2}}
\newcommand{\Ch}{\pic[1em]{slike/frog}}
\renewcommand{\ch}{\pic{slike/frog}}
\renewcommand{\sh}{\pic{finthesis_assets/unikg_logo}}
\newcommand{\m}{\pic{finthesis_assets/finkg_logo}}
\renewcommand{\j}{\pic{slike/prijava}}

\Large
,,\Ch а\sh у \m еда \j о\sh т нико не попи, \sh то \j е \ch а\sh о\m\ жу\ch и не загр\ch и; \ch а\sh а жу\ch и и\sh те \ch а\sh у \m еда, с\m и\j е\sh ане на\j лак\sh е се пи\j у.''
}

\section{Разрада}

Програмирање је једно од најзаступљенијих поља инжењества данашњице. Постоје разни програмски језици. Историски су језици били процедурални, након чега настају објектно-оријентисани језици и језици функционалног програмирања. Неки од занимљивих програмских језика који су и функционални и објектно-оријентисани су Пајтон \cite{pythonsite} и Скала \cite{scalasite}, с тиме што је већи акценат на функционално програмирање стављен у оквиру Скала програмског језика \cite{scalasite}.

\subsection{Пример рекурзије у Пајтону}

Листинг~\ref{lst:recpy} садржи рекурзивну имплементацију функције $f(a,b) = a^b$, где је $b$ цео број. Редови~\ref{lst:recpy:edgefirst},~\ref{lst:recpy:edgesecond}~и~\ref{lst:recpy:main} садрже рекурзивне позиве функцие \prog{exp}, мада главни део рекурзије се одвија у реду~\ref{lst:recpy:main}, док редови~\ref{lst:recpy:edgefirst}~и~\ref{lst:recpy:edgesecond} обухватају граничне случајеве за вредности целобројног параметра $b$. Такође је илустрована примена технике дефанзивног програмирања (ред~\ref{lst:recpy:assert}), где се уверавамо да је $b$ паран број пре него што резултат позива функције \prog{exp(a, b//2)} множимо самим собом. У случају да се у будућности мало измени изворни к\^{о}д ове функције, може се случајно занемарити овај услов, па ће наредба \prog{assert} и ухватити такав превид.

\begin{lstlisting}[language=Python, caption={Рекурзивна експоненцијална функција реализована у Пајтон програмском језику.}, label={lst:recpy}, escapechar={`}]
def exp(a, b):
    if b == 0:
        return 1
    elif b < 0:
        return 1/exp(a, -b)`\label{lst:recpy:edgefirst}`
    elif b % 2 != 0:
        return a * exp(a, b - 1)`\label{lst:recpy:edgesecond}`
    assert b % 2 == 0, "b must be even before proceeding"`\label{lst:recpy:assert}`
    half_exp = exp(a, b//2)`\label{lst:recpy:main}`
    return half_exp * half_exp
\end{lstlisting}

Временска сложеност ове имплементације је $\mathcal{O}(\log_2|b|)$. Просторна сложеност је такође $\mathcal{O}(\log_2|b|)$, пошто се путем рекурзије попуњава позивни стек за функцију \prog{exp}, а максимална висина тог стека је сразмерна броју корака који је потребан да би се израчунала вредност функције.

\section{Технологије}
\subsection{Верилог}
Документ о Верилогу
Увод у Верилог

Верилог је језик за описивање хардвера (HDL) који омогућава инжењерима да модификују, симулирају и верификују дигиталне системе. Комбинује симболичко програмирање и структурно моделирање, што га чини веома флексибилним алатом у пројектовању интегрисаних кола и других дигиталних уређаја.
Историја

Верилог је првобитно развијен 1984. године од стране Џона Р. Гурлија у компанији Gateway Design Automation, где је првобитно служио као алат за симулацију. Како је верилог добијао на популарности, постао је основа за многе комерцијалне алате за дизајн хардвера. У 2005. години, IEEE је стандартизовао Верилог као IEEE 1364, што је додатно унапредило његову употребу и интеграцију у индустрији. Са развојем нових технологија, попут FPGA и ASIC, Верилог је наставио да се прилагођава и остаје актуелан.
Употреба

Верилог се користи у различитим фазама развоја хардвера, укључујући:

    Пројектовање: Инжењери користе Верилог да опишу архитектуру и функционалност дигиталних кола. Овај језик омогућава моделирање хардверских компоненти на различитим нивоима, од логичког до физичког.

    Тестирање: Верилог се широко користи за писање тестних бенчова, који су структуре које помажу у тестирању функционалности хардвера. Омогућава инжењерима да провере да ли дизајн функционише према спецификацијама.

    Симулација: Симулација Верилога омогућава детаљно проучавање понашања дигиталних система под различитим условима и у различитим сценаријима.

Функционалне ствари

    Синтакса: Верилог нуди низ конструкција које олакшавају описивање хардвера. Користи блокове, модули и поруке, што чини код читљивим и лако разумљивим.

    Паралелизам: Верилог подржава паралелно извршавање, што одражава реалан рад хардвера. Ово је кључно за моделирање сложених система где више компонената ради истовремено.

    Верификација: Верилог подржава формалну верификацију, што значи да инжењери могу да провере да ли дизајн задовољава специфичне логичке и временске захтеве. Ово смањује ризик од грешака у коначном производу.

Примена

Верилог се користи у различитим индустријама, укључујући:

    Полупроводничка индустрија: Верилог је основа за дизајн и верификацију интегрисаних кола (IC), укључујући FPGA и ASIC.

    Аутомобилска индустрија: У дизајну аутомобилских система, као што су контролери мотора и безбедносни системи.

    Телекомуникације: У развоју система за пренос података и комуникационе уређаје.

    Потрошачка електроника: За пројектовање и верификацију уређаја као што су телевизори, мобилни telefoni и рачунари.

Закључак

Верилог представља кључни инструмент у савременом дизајну хардвера, пружајући инжењерима могућност да ефикасно развијају, тестирају и верификују сложене дигиталне системе. Његова способност да комбинује високо ниво моделирања и детаљно симулирање чини га незаменљивим алатом у индустрији.

\subsection{Csharp}
 Увод у Csharp

Csharp (изговорено "си шарп") је програмски језик развијен од стране компаније Microsoft 2000. године као део .NET платформе. Дизајниран је као општи сврховни језик, погодан за развој различитих апликација, од веб и мобилних до десктоп и игара.
Историја

Csharp је развијен у Microsoftu 2000. године, а првобитно га је дизајнирао Андерс Хејсборд као део иницијативе за .NET платформу. Циљ је био да се створи језик који ће омогућити програмерима да лако и ефикасно развијају апликације за Windows.

    Csharp 1.0 (2000): Прва верзија, представила је основне функције као што су објектно-оријентисано програмирање, основне типове података и основне синтаксне конструкције.

    Csharp 2.0 (2005): Уведена је подршка за генеричке типове, а такође је побољшана подршка за делегате и догађаје. Ова верзија је такође додала анонимне методе, што је олакшало управљање догађајима.

    Csharp 3.0 (2007): Додата је LINQ (Language Integrated Query), што је значајно олакшало рад са подацима. Уведени су и анонимни типови и методе, као и подршка за упитнике у стилу SQL.

    Csharp 4.0 (2010): Ова верзија је донела подршку за динамичке типове, што је омогућило интеграцију са динамичким језицима и COM објектима. Такође је уведена и побољшана подршка за параметре именоване и опционалне параметре.

    Csharp 5.0 (2012): Уведене су асинхроне методе, што је значајно убрзало обраду у апликацијама које обрађују податке или раде са интернетом.

    Csharp 6.0 (2015): Додата је подршка за интерполацију стрингова и побољшана синтакса, што је учинило код читљивијим и краћим.

    Csharp 7.0 (2017): Ова верзија је донела многе нове функције, укључујући локалне функције, tuple типове и pattern matching.

    Csharp 8.0 (2019): Уведена је подршка за nullable референце, асинхроне стримове и нове опције за pattern matching, што је значајно унапредило рад са подацима.

    Csharp 9.0 (2020): Додата је подршка за records, што олакшава рад с неименованим објектима и значајно побољшава управљање иммутабилним објектима.

    Csharp 10.0 (2021): Уведене су нове функције попут глобалних using директива и подршка за кратке и локалне функции.

    Csharp 11.0 (2022): Најновија верзија, представљена у оквиру .NET 7, доноси нове функционалности као што су generic math, нови string интерполације и побољшања у pattern matching-у.

Csharp је током година еволуирао и прилагођавао се потребама развојних тимова, одржавајући своју позицију као један од најпопуларнијих програмских језика у индустрији. Свака нова верзија додаје значајне функционалности, чинећи Csharp ефикаснијим за развој савремених апликација.
Употреба

Csharp се користи у различитим областима, укључујући:

    Развој веб апликација: С помоћ ASP.NET, програмери могу да креирају динамичне веб странице и веб апликације.
    Развој десктоп апликација: Windows Forms и WPF (Windows Presentation Foundation) омогућавају изградњу графичких корисничких интерфејса.
    Развој игара: Csharp је основни језик за Unity, један од најпопуларнијих алата за развој игара.
    Развој мобилних апликација: С коришћењем Xamarin-a, програмери могу да креирају апликације за iOS и Android.

Функционалне ствари

    Објектно-оријентисано програмирање: Csharp подржава класичне објектно-оријентисане концепте као што су наследство, инкапсулација и полиморфизам.
    Типизирање: Csharp користи статичко типизирање, што значи да се типови променљивих проверавају на компајлеру, смањујући могућност грешака у времену извршавања.
    Сигурност: Csharp нуди механизме за управљање меморијом и сигурност, као што су Garbage Collection и контроле типова.

Примена

Csharp се користи у различитим индустријама, укључујући:

    Финансијске услуге: Развој апликација за обраду података и аналитике.
    Здравство: Стварање система за управљање подацима о пацијентима и електронским здравственим записима.
    Едукација: Развој образовних платформи и алата.

Закључак

Csharp представља моћан и флексибилан програмски језик који се широко користи у индустрији. Са својом једноставном синтаксом и богатим функционалностима, Csharp остаје популаран избор за програмере.

\subsection{Razor pages}
Наравно! Ево секције о Razor Pages:

  Документ о Razor Pages

   Увод у Razor Pages
Razor Pages је нови модел за развој веб апликација у ASP.NET Core, који олакшава изградњу динамичких веб страница. Овај модел нуди структуриран приступ и удобнији начин управљања логиком и подацима, користећи Razor синтаксу.

   Историја
Razor Pages је први пут представљен у ASP.NET Core 2.0, као одговор на потребу за једноставнијим моделом за развој веб апликација у поређењу са традиционалним MVC (Model-View-Controller) архитектурама. Развојни тим у Microsoftu је желео да омогући лакше управљање страницама, чинећи их лакшим за коришћење и разумевање.

-   ASP.NET Core 2.0 (2017)  : Увођење Razor Pages, које су осмишљене да поједноставе развој веб страница, омогућавајући програмерима да лако управљају логиком странице без потребе за сложеним контролерима.
  
-   ASP.NET Core 3.0 (2019)  : Додата је подршка за нове функције као што су интеграција са Blazor-ом, што је омогућило развој интерактивних веб апликација.

-   ASP.NET Core 5.0 (2020)  : Увео је значајна побољшања у перформансама и подршку за нове функције у Razor Pages, укључујући побољшано управљање зависностима и аутентификацију.

-   ASP.NET Core 6.0 (2021)  : Додатна побољшања, укључујући минималне АPI и побољшану подршку за контекст хостовања, чинећи развој веб апликација ефикаснијим.

   Употреба
Razor Pages се користи за:

-   Развој динамичких веб страница  : Пружа структуру за развој страница које реагују на корисничке интеракције.
-   Моделирање података  : Олакшава обраду података и интеракцију са базом података.
-   Интеграцију с JavaScript и CSS  : Подржава интеграцију front-end технологија, чинећи развој комплетним.

   Функционалне ствари
-   Razor синтакса  : Користи Razor синтаксу за генерисање HTML-а, што омогућава укључивање C  кода у .cshtml датотеке.
-   Структура  : Razor Pages користи PageModel класу која управља логиком странице, што побољшава организацију кода.
-   Подршка за аутентификацију  : Лако се интегрише са механизмима за аутентификацију и ауторизацију.

   Примена
Razor Pages се користе у различитим типовима веб апликација, укључујући:

-   Корпоративне веб апликације  : Развој сложених система за управљање подацима.
-   Лични и портфолио сајтови  : Лакше управљање садржајем и интеракцијом са корисницима.
-   Интерактивне веб апликације  : Користи се у комбинацији с JavaScript за динамичке корисничке интерфејсе.

   Закључак
Razor Pages представља моћан модел за развој веб апликација, нудећи лакши и структуриранији начин за изградњу динамичних веб страница у ASP.NET Core. Своју популарност дугује једноставности и интеграцији с другим .NET технологијама.


\subsection{Doker}
Ево секције о Dockeru:

  Документ о Dockeru

   Увод у Docker
Docker је платформа за развој, испоруку и покретање апликација у контејнерима. Контејнери омогућавају програмерима да пакују апликације и њихове зависности у изолованом окружењу, што олакшава преносивост и управљање.

   Историја
Docker је први пут представљен 2013. године од стране Соломона Хајка, који је развио отворени пројекат за управљање контејнерима. Циљ је био да се поједностави процес испоруке софтвера и убрза развојни циклус.

-   Docker 1.0 (2014)  : Уведена прва стабилна верзија, што је омогућило широко усвајање технологије у индустрији.

-   Docker Swarm (2015)  : Додата подршка за управљање кластерима контејнера, што омогућава хоризонтално скалирање.

-   Docker Compose (2015)  : Уведен алат за дефинисање и управљање вишеконтейнерским апликацијама, олакшавајући конфигурацију и покретање апликација.

-   Docker 17.06 (2017)  : Уведена подршка за Kubernetes, што је омогућило управљање контејнерима у кластерима.

-   Docker 20.10 (2020)  : Уведене нове функције, укључујући побољшања у управљању ресурсима и сигурности.

   Употреба
Docker се користи за:

-   Развој апликација  : Лакше управљање зависностима и окружењем.
-   Деплојмент  : Брзо и лако распоређивање апликација у различитим окружењима.
-   Тестирање  : Изолација тестних окружења, што смањује ризик од конфликата.

   Функционалне ствари
-   Контејнери  : Изоловани системи који могу да раде независно, што омогућава лакше управљање зависностима.
-   Dockerfile  : Конфигурациони фајл који описује кораке за изградњу Docker слике.
-   Docker Hub  : Овлашћена регистрација за дељење и управљање Docker сликама.

   Примена
Docker се користи у различитим индустријама, укључујући:

-   Финансијске услуге  : За управљање сложеним апликацијама и микросервисима.
-   Здравство  : За управљање подацима и системима за обраду.
-   Развој софтвера  : За убрзање развојног циклуса и побољшање сарадње у тимовима.

   Закључак
Docker представља кључни инструмент у модерном развоју софтвера, омогућавајући бржи и ефикаснији процес развоја и управљања апликацијама у различитим окружењима.
\subsection{Git i Github}
Git је дистрибуирани систем за контролу верзија, који омогућава програмерима да прате промене у кодовима и сарађују на пројектима. GitHub је веб платформа која се базира на Gitu, омогућавајући корисницима да хостују и управљају Git репозиторијима, као и да сарађују на отвореним пројектима.
Историја

Git је развио Линус Торвалдс 2005. године као алтернативу за системи за контролу верзија, попут BitKeeper. Основна идеја била је да се створе алати који су лакши за употребу и флексибилнији, што је резултирало у моћном и ефикасном систему за управљање кодом.

    Git 1.0 (2005): Увођење основних функционалности, као што су управљање верзијама и храњење репозиторија.

    GitHub (2008): Основан као платформа за хостовање Git репозиторија, што је олакшало сарадњу међу програмерима и подстакло отворени развој софтвера.

    Git 2.0 (2014): Побољшања у перформансама и увод нових функција као што су интерактивне рефакторинг опције.

    GitHub Actions (2018): Уведена подршка за CI/CD (континуална интеграција/континуално испорука), омогућавајући аутоматизацију радних токова у репозиторијима.

Употреба

Git и GitHub се користе за:

    Контролу верзија: Пружање историје свих промена у кодовима, чиме се олакшава враћање на претходне верзије.
    Сарадњу: Omogućava програмерима да раде на истом пројекту, управљајући конфликтима и интегришући промене.
    Управљање пројектима: GitHub пружа алате за праћење проблема, документацију и управљање верзијама.

Функционалне ствари

    Грановање: Git подржава грановање, што омогућава програмерима да раде на различитим верзијама пројекта без утицаја на главну линију развоја.
    Pull Requests: GitHub-ова функција која омогућава корисницима да предложе промене у кодовима и да их рецензирају пре него што буду спојене у главни репозиториј.
    Issues: Механизам за праћење проблема, захтева и грешака у пројекту.

Примена

Git и GitHub се користе у разним индустријама, укључујући:

    Развој софтвера: За управљање и сарадњу на пројектима, било да се ради о малим или великим тимовима.
    Образовање: За учење и пројектну сарадњу у програмским курсевима.
    Отворени извор: Платформа за хостовање и развој пројеката отвореног кода.

Закључак

Git и GitHub представљају кључне алате у савременом развоју софтвера, пружајући програмерима моћна средства за контролу верзија и сарадњу на пројектима. Њихова доступност и флексибилност чине их незаменљивим у развојном процесу.

\section{Верилог}


У Верилогу, модули су основне грађевинске блокове. Они су као функције у програмским језицима, али уместо да извршавају акције, они описују хардверску структуру. Синтакса за модул је следећа:
\begin{lstlisting}[language=Verilog, caption={Команде }, label={lst:recpy}, escapechar={`}]
module ime_modula (ulazi, izlazi);
    input ulaz;
    output izlaz;

    // Декларација сигнала и логика модула
endmodule
\end{lstlisting}
Овде, ime\_modula представља назив модула, а ulazi и izlazi су параметри који дефинишу улазе и излазе модула. Унутар модула, можете декларативно описивати сигнала и логичке операције.

Верилог подржава неколико основних типова података, што је важно за дефинисање хардверских компоненти:

    wire: Користи се за повезивање модула. Не може да чува вредности самостално.
    reg: Користи се за складиштење вредности, а може се модификовати у секвенцијалним логичким операцијама.
    integer: За целобројне вредности, корисно за бројчане операције.
    real: За реалне (двојне) вредности, које су корисне у неким симулацијама.

Пример декларације типова:
\begin{lstlisting}[language=Verilog, caption={Команде }, label={lst:recpy}, escapechar={`}]
wire a;
reg b;
integer c;
real d;
\end{lstlisting}
Верилог подржава разне операторе који се користе за извршавање логичких и математичких операција:

    Логичке операторе: \&\&, ||, !, који се користе за логичке операције.
    Битни оператори: \&, |, \^, ~, који раде на битовима сигнала.
    Поређење: ==, !=, >, <, >=, <=, који се користе за поређење вредности.

Пример коришћења оператора у логичкој операцији:
\begin{lstlisting}[language=Verilog, caption={Команде }, label={lst:recpy}, escapechar={`}]
assign y = a & b; // логичко И
\end{lstlisting}
Контролне структуре у Верилогу, као што су условне конструкције и петље, сличне су онима у класичним програмским језицима. Оне су кључне за имплементацију сложене логике.

    if-else конструкција:
\begin{lstlisting}[language=Verilog, caption={Команде }, label={lst:recpy}, escapechar={`}]
if (a == 1) begin
    // логика за услов
end else begin
    // логика за друго стање
end
\end{lstlisting}
case конструкција:
\begin{lstlisting}[language=Verilog, caption={Команде }, label={lst:recpy}, escapechar={`}]
case (selector)
    2'b00: out = 4'b0000;
    2'b01: out = 4'b0001;
    default: out = 4'bxxxx;
endcase
\end{lstlisting}
Догађаји су важан аспект Верилога, јер се користе у always блоковима да означе услове под којима ће се логика извршити. Овде су објашњени неки од кључних догађаја:

    posedge: Означава да ће логика унутар always блока бити активна на позитивном иљу (подухвату) сигнала. То значи да ће се блок извршити када сигнал пређе из нуле у један.


\begin{lstlisting}[language=Verilog, caption={Команде }, label={lst:recpy}, escapechar={`}]
always @(posedge clk) begin
    q <= d; // активација на позитивном иљу
end
\end{lstlisting}

    negedge: Означава да ће логика бити активна на негативном иљу сигнала, односно када сигнал пређе из један у нулу.

\begin{lstlisting}[language=Verilog, caption={Команде }, label={lst:recpy}, escapechar={`}]
always @(negedge reset) begin
    q <= 0; // активација на негативном иљу
end
\end{lstlisting}

    Звездица (*): Користи се за означавање свих промена на сигналу, без обзира на то да ли је позитиван или негативан иљ. Ово је корисно за чување стања или обраду свих догађаја.

\begin{lstlisting}[language=Verilog, caption={Команде }, label={lst:recpy}, escapechar={`}]
always @(posedge clk or *) begin
    // активација на позитивном иљу или другим променама
end
\end{lstlisting}

\subsection{Icarius}
Icarus Verilog је отворени изворни (open-source) компајлер и симулатор за хардверски описни језик Верилог. Дизајниран је за дизајнере и инжењере који желе да симулирају и тестирају своје дигиталне дизајне без потребе за комерцијалним софтвером. Овај алат подржава велики број функција Верилога, укључујући синтаксу и семантику, што га чини погодним за развој и проверу сложених хардверских пројеката.

Основне Карактеристике

    Подршка за Верилог и SystemVerilog: Icarus Verilog подржава стандардне Верилог функције, али такође нуди подршку за SystemVerilog, што је важан корак за кориснике који желе да користе напредне карактеристике овог језика.

    Отворени извор: Икарус је доступан бесплатно под GNU General Public License (GPL), што омогућава корисницима да измене и прилагоде изворни код према својим потребама.

    Интеграција са другим алатима: Icarus Verilog може да се интегрише са другим алатима за тестирање и симулацију, као што су GTKWave за визуализацију таласних облика и Verilator за оптимизацију кодова.

    Лакоћа коришћења: Има једноставан интерфејс командне линије, што га чини погодним за програмере који раде у окружењу терминала. Користи се за компилирање и симулирање Верилог модела.

    Подршка за различите платформе: Icarus Verilog је доступан на више оперативних система, укључујући Windows, Linux и macOS, што га чини доступним широком кругу корисника.

Како почети Да бисте започели рад са Icarus Verilog, потребно је да инсталирате софтвер. На Linux системима, инсталација може да се изврши путем пакет менаџера, док на Windows-у можете преузети и инсталирати из званичне библиотеке.

Примери Када инсталирате Icarus Verilog, можете написати једноставан Верилог модул и компајлирати га:

    Напишите Верилог код у датотеци example.v:

verilog

module example;
    reg a;
    initial begin
        a = 0;
        $display("Value of a: %b", a);
    end
endmodule

    Компилирајте код:

bash

iverilog -o example example.v

    Извршите симулацију:

bash

vvp example


\section{First Razor app}
2. Креирање новог Razor Pages пројекта

Отвори командну линију и уради следеће:

bash

dotnet new webapp -n MyRazorApp
cd MyRazorApp

Ово ће креирати нови Razor Pages пројекат у директоријуму MyRazorApp.
3. Структура пројекта

Пројекат ће имати следеће важне делове:

    Pages директоријум: Садржи .cshtml и .cshtml.cs фајлове за твоје Razor странице. Свака страница има свој модел (PageModel) у .cshtml.cs фајлу.
    wwwroot директоријум: Овде се налазе статични ресурси као што су CSS, JavaScript и слике.
    Startup.cs: Конфигурациони фајл за приложну логике, где се подешавају услуге и мапирање рута.
    appsettings.json: Фајл за конфигурацију апликације, где можеш подесити опције као што су веза с базом података.

4. Разумевање Razor Page компоненти

    .cshtml: Садржи HTML и Razor синтаксу. У њему се пишу визуелне компоненте.
    .cshtml.cs: Дефинише логичке компоненте странице, укључујући методе за обраду захтева (OnGet, OnPost).
    PageModel: Класа која представља модел странице, садржи податке и методе који су потребни за обраду интеракција.

Пример Index.cshtml:

html

@page
@model IndexModel

<h2>Добродошли на моју Razor страницу!</h2>

Пример Index.cshtml.cs:

csharp

using Microsoft.AspNetCore.Mvc.RazorPages;

public class IndexModel : PageModel
{
    public void OnGet()
    {
        // Логика за GET захтев
    }
}

5. Покретање Razor Pages апликације

У командној линији, у директоријуму пројекта, покрените следећу команду:

bash

dotnet run

Ово ће покренути сервер. Отвори прегледач и иди на https://localhost:5001 (или http://localhost:5000).
6. Публикација Razor Pages апликације

Када си спреман да објавиш апликацију, можеш да користиш следеће кораке:

    Пређи у директоријум пројекта:

    bash

cd MyRazorApp

Изврши команду за публикацију:

bash

    dotnet publish -c Release -o ./publish

    Ова команда ће саставити апликацију и копирати све потребне фајлове у publish директоријум.

    Копирај фајлове на сервер: Сада можеш да копираш садржај из publish директоријума на сервер на који желиш да објавиш апликацију.

    Покрени на серверу: На серверу, можеш користити IIS, Nginx или друге сервере за хостовање .NET апликација. Увери се да су сви потребни зависности инсталирани.

Закључак

Рazor Pages је моћан и лак за коришћење модел за развој веб апликација. Када разумеš структуру пројекта и како да објавиш апликацију, можеш креирати сложене и интерактивне веб странице.

\begin{lstlisting}[language=bash, caption={Команде за креирање и покретање разор апликације из терминала.}, label={lst:recpy}, escapechar={`}]
dotnet new webapp -n MyRazorApp
cd MyRazorApp
dotnet run
dotnet publish -c Release -o ./publish
\end{lstlisting}

\section{Deployment}
Да бисмо пустили новију верзију да продукцију користићемо докер, а платформа коју користимо је Render. 
Прво што треба да урадимо је да креирамо докер слику апликације. Да бисмо то одрадили имамо следећи докер фајл.

\begin{lstlisting}[language=Docker, caption={Докер фајл - Команде за подешавање окружења и пребацивање апликације.}, label={lst:recpy}, escapechar={`}]
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
WORKDIR /app
EXPOSE 8080
EXPOSE 8081
RUN apt update && \
    apt install -y iverilog

FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
ARG BUILD_CONFIGURATION=Debug
WORKDIR /src
COPY ["OnlineVerilog/OnlineVerilog.csproj", "OnlineVerilog/"]
RUN dotnet restore "OnlineVerilog/OnlineVerilog.csproj"
COPY . .
WORKDIR /src/OnlineVerilog
RUN dotnet build "OnlineVerilog.csproj" -c ${BUILD_CONFIGURATION} -o /app/build

FROM build AS publish
ARG BUILD_CONFIGURATION=Debug
RUN dotnet publish "OnlineVerilog.csproj" -c ${BUILD_CONFIGURATION} -o /app/publish 

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT [ "dotnet", "OnlineVerilog.dll" ]
\end{lstlisting}
Опис свих команди из Docker фајла
1. Ова команда поставља основу за контејнер користећи ASP.NET 8.0 слику. Назив "base" се користи као референца у каснијим корацима.
2. Поставља радни директоријум у контејнеру на /app. Све следеће команде ће се извршавати у овом директоријуму.
3. Ова команда објављује порт 8080. Ово не отвара порт, али указује на то да ће апликација слушати на овом порту.
4. Слично као и претходна команда, објављује порт 8081 за потенцијалну употребу.
5. Ова команда ажурира пакете у систему и инсталира iverilog, алат за симулацију Verilog кода. Додатак -y аутоматски одобрава инсталацију без потребе за потврдом.
6. Ова команда поставља нови слој контејнера на основу .NET SDK 8.0. Назив "build" се користи за идентификацију овог корака.
7. Дефинише аргумент BUILD\_CONFIGURATION са подразумеваном вредношћу Debug, који се може користити у каснијим корацима.
8. Поставља радни директоријум на /src, где ће се налазити изворни код.
9. Копира .csproj фајл пројекта из локалног система у контејнер.
10. Извршава команду за обнављање зависности пројекта на основу .csproj фајла.
11. Копира све фајлове из локалног директоријума у радни директоријум у контејнеру.
12. Поставља радни директоријум на /src/OnlineVerilog, где се налази сам пројекат.
13. Извршава компилацију пројекта. Резултати компилације ће бити смештени у /app/build.
14. Креира нови слој на основу "build" корака за публиковање апликације.
15. Извршава публиковање пројекта, стварајући финалну верзију апликације која ће бити смештена у /app/publish.
16. Креира завршни слој на основу "base" корака.
17. Поставља радни директоријум на /app, где ће бити смештени финални фајлови.
18. Копира све фајлове из /app/publish из претходног корака у тренутни радни директоријум.
19. Ова команда поставља ENTRYPOINT контејнера, што значи да ће се апликација покренути помоћу dotnet OnlineVerilog.dll када се контејнер стартује.

Кад имамо креаиран докер фајл онда покрећемо следеће команде:
\begin{lstlisting}[language=bash, caption={Креирање докер слике.}, label={lst:recpy}, escapechar={`}]
docker build -t onlineverilogdck4 .
\end{lstlisting}
Кад смо креирали докер слику сад је потребно да је објавимо на  docker hub. Али пре тога је потребно да креирамо налог и да се креаира нови repository.
\begin{lstlisting}[language=bash, caption={Команде за пребацивање докер слике на докер хуб.}, label={lst:recpy}, escapechar={`}]
docker tag dockertest:latest tonkac/docker-test-repo:latest
docker push tonkac/docker-test-repo:latest
\end{lstlisting}
Затим је потебно покренути команду . да бисмо обележили нашу докер слику и додати јој аргументе као што је корисник и репозиторијум из докер хуба. И са другом командом започињемо процес објављивања докер слике на докер хуб.

Следећи корак је да нашу докер слику путстимо на продукцији, а за то ћемо користити Render. Render је хостинг платформа која олакшава распоређивање и управљање веб апликацијама и једна од функционалти које нуде и коју ћемо користити за овај пројекат је покретање апликације из докер слике. Потребно је да одемо на Render-ов сајт https://render.com/ и да креирамо налог. Кад имамо  спреман налог онда треба да креирамо нови пројекат, изаберемо какав услугу желимо, што у нашем случају је веб сервис. Затим за начин пустања апликације на продукцију изабраћемо да се то ради из постојеће докер слике. Уколико је докер слика приватно биће потребно да се додају и креденцијали за приступ.


\section{My app}
\subsection{Three layer model}
Тријасни модел је архитектонска структура која се користи у развоју софтвера и системском дизајну. Овај модел се често примењује у различитим контекстима, укључујући веб апликације, базе података и дистрибуиране системе. Основна идеја овог модела је да подели систем на три одвојена слоја: презентациони слој, логички слој и слој података. Овај приступ побољшава управљивост, модуларност и могућност одржавања система.
Слојеви Тријасног Модела
1. Презентациони слој (Presentation Layer)

Презентациони слој је оно што корисници виде и са чим интерагују. Он обухвата све аспекте корисничког интерфејса, укључујући дизајн, распоред и интеракцију. Основна функција овог слоја је да пружи корисницима интерфејс за комуникацију са апликацијом.

    Функције:
        Приказ информација корисницима.
        Прихватање корисничких уноса.
        Пружање визуелних повратних информација.

    Технологије: HTML, CSS, JavaScript за веб апликације; XAML за Windows апликације; SwiftUI за iOS апликације.

2. Логички слој (Logic Layer)

Логички слој обрађује пословну логіку апликације. Он управља интеракцијама између презентационог слоја и слоја података, обрађује пословне правила и операције, а такође комуницира са спољним системима.

    Функције:
        Обрађује логичке операције.
        Управља подацима из слоја података.
        Извршава пословна правила.

    Технологије: Серверски језици као што су Java, C#, Python; фреймворци као што су Spring, ASP.NET, Django.

3. Слој података (Data Layer)

Слој података одговара за складиштење и управљање подацима. Он пружа интерфејс за приступ подацима, било локално или преко мреже. Овај слој управља базама података и другим изворима података.

    Функције:
        Чување, извлачење и модификација података.
        Управљање трансакцијама.
        Осигуравање интегритета података.

    Технологије: Системи управљања базама података (DBMS) као што су MySQL, PostgreSQL, MongoDB.

Предности Тријасног Модела

    Модуларност: Свакој компоненти (слоју) се може управљати одвојено, што олакшава развој и одржавање.
    Побољшана безбедност: Изолација слојева омогућава бољу контролу приступа подацима и логичким операцијама.
    Лакше тестирање: Сваки слој може се тестирати независно, што олакшава идентификацију и решавање проблема.
    Могућност поновне употребе: Компоненте из једног слоја могу се лако поново користити у другим пројектима.




\section{LITERATIRa}
верилог
Thomas, D. (2004). Verilog HDL: A Guide to Digital Design and Synthesis. Prentice Hall.
Palnitkar, S. (2003). Verilog HDL. Sun Microsystems Press.
Rabaey, J. M., \& Pedram, M. (2003). Low Power Design Essentials. Springer.
Katz, R. H. (1994). Contemporary Logic Design. Addison-Wesley.  

Ево референци за C sharp:

1.   Microsoft Docs - C sharp Guide  : [C sharp Guide](https://docs.microsoft.com/en-us/dotnet/csharp/)
2.   W3Schools - C sharp Tutorial  : [W3Schools C sharp](https://www.w3schools.com/cs/)
3.   Codecademy - Learn C sharp  : [Codecademy C sharp Course](https://www.codecademy.com/learn/learn-c-sharp)
4.   Pluralsight - C sharp Paths  : [Pluralsight C sharp](https://www.pluralsight.com/paths/csharp)
5.   C sharp Programming Guide (Microsoft Learn)  : [C sharp Programming Guide](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/)
6.   C sharp Language Specification (ECMA-334)  : [C sharp Language Specification](https://www.ecma-international.org/publications/standards/Ecma-334.htm)

  Референце razor pages
1.   Microsoft Docs - Razor Pages  : [Razor Pages Overview](https://docs.microsoft.com/en-us/aspnet/core/razor-pages/)
2.   Microsoft Learn - ASP.NET Core Razor Pages  : [Learn Razor Pages](https://learn.microsoft.com/en-us/training/modules/build-web-apps-razor-pages/)
3.   Tutorialspoint - Razor Pages Tutorial  : [Tutorialspoint Razor Pages](https://www.tutorialspoint.com/aspnet\_core/aspnet\_core\_razor\_pages.htm)
4.   Pluralsight - ASP.NET Core Razor Pages  : [Pluralsight Razor Pages](https://www.pluralsight.com/courses/aspnet-core-razor-pages)


  Референце doker
1.   "Docker Deep Dive" by Nigel Poulton  : [Docker Deep Dive](https://www.nigelpoulton.com/books/)
2.   "The Docker Book" by James Turnbull  : [The Docker Book](https://www.dockerbook.com/)
3.   "Docker in Action" by Jeffrey Nickoloff  : [Docker in Action](https://www.manning.com/books/docker-in-action)
4.   "Learn Docker in a Month of Lunches" by David Flanagan  : [Learn Docker in a Month of Lunches](https://www.manning.com/books/learn-docker-in-a-month-of-lunches)


\section{Закључак}

Овим радом обрађене су разне теме: од програмирања, преко векторске графике, до писања докумената. Али оно што је најважније је то што је представљено како се може написати \thesiscase{и} рад у \LaTeX-у, као и како се користи већина елемената који су за израду рада потребни.

\makebibliography

\end{document}